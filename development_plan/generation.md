# Техническое задание на разработку модулей симулятора STM32F103C8T6

## 1. Общие принципы работы эмулятора

Эмулятор работает по конвейерному принципу: **вход → обработка → выход**. Каждый модуль получает входные данные, выполняет свою логику и формирует выходные данные для других модулей или пользователя.

**Базовый цикл обработки:**
1. Получение входного воздействия (команда пользователя, тактовый сигнал, обращение к памяти)
2. Валидация входных данных
3. Выполнение внутренней логики
4. Обновление внутреннего состояния
5. Формирование выходных данных (сигналы другим модулям, вывод пользователю)

---

## 2. Модуль ядра процессора (Core)

### 2.1. Назначение
Эмуляция процессорного ядра ARM Cortex-M3: выполнение инструкций, управление регистрами, обработка исключений.

### 2.2. Входные данные

| Источник | Тип данных | Описание |
|----------|------------|----------|
| Пользователь | Команда | `reset`, `step`, `run`, `stop`, `get_reg <name>`, `set_reg <name> <value>` |
| Память | uint32_t | Инструкция по адресу PC |
| NVIC | bool | Сигнал наличия ожидающего прерывания |
| NVIC | uint32_t | Вектор прерывания для обработки |
| Шина | uint32_t | Данные при операциях загрузки (LDR) |

### 2.3. Выходные данные

| Получатель | Тип данных | Описание |
|------------|------------|----------|
| Память/шина | Запрос | Чтение/запись по адресу (размер: byte/halfword/word) |
| NVIC | bool | Подтверждение обработки прерывания |
| NVIC | Запрос | Очистка ожидающего прерывания |
| Пользователь | Структура | Текущее состояние (PC, регистры R0-R15, xPSR, флаги) |
| Логгер | Строка | Информация о выполненной инструкции |

### 2.4. Внутреннее состояние

```cpp
struct CoreState {
    uint32_t registers[16];      // R0-R15 (R13 = SP, R14 = LR, R15 = PC)
    uint32_t xpsr;                // Program Status Register
    bool is_thumb_mode;           // Режим выполнения (всегда true для Cortex-M3)
    bool interruptible;           // Разрешены ли прерывания
    uint32_t current_irq;         // Текущее обрабатываемое прерывание (0 = нет)
    uint32_t cycles_executed;     // Счетчик выполненных тактов
};
```

### 2.5. Сценарий работы: выполнение инструкции

```
Вход: Команда "step" от пользователя
      Текущий PC = 0x08000100

Процесс:
1. Валидация: проверить, что PC в пределах Flash-памяти
2. Запрос к шине: read(0x08000100, 4) → получение инструкции
3. Декодирование: определить тип инструкции (ADD, MOV, B, и т.д.)
4. Исполнение:
   - Если инструкция требует чтения данных: запрос к шине read(адрес, размер)
   - Изменение регистров согласно логике инструкции
   - Обновление флагов в xPSR (N, Z, C, V)
   - Обновление PC (обычно PC += 4, но может измениться при ветвлениях)
5. Проверка прерываний: если прерывание ожидает и разрешено → вход в обработчик
6. Обновление счетчика тактов: cycles_executed += такты_инструкции

Выход: Новое состояние регистров
       Новый PC
       Обновленные флаги
       Сигнал пользователю: "Инструкция 0xE0821003 (ADD R1, R2, R3) выполнена"
```

### 2.6. Сценарий работы: обработка прерывания

```
Вход: Сигнал от NVIC: has_pending = true, irq_number = 11 (TIM2)

Процесс:
1. Сохранение контекста:
   - Запись в стек: xPSR, PC, LR, R12, R3, R2, R1, R0
   - Обновление SP
2. Получение вектора: запрос к NVIC get_vector(11)
3. Переход в режим обработчика:
   - Установка PC = vector_address
   - Установка LR в специальное значение (0xFFFFFFF9)
   - Установка current_irq = 11
4. Выполнение обработчика (последующие инструкции)

Выход: Измененный стек
       Новый PC
       Новый режим выполнения
```

---

## 3. Модуль контроллера прерываний (NVIC)

### 3.1. Назначение
Управление прерываниями: приоритизация, маскирование, маршрутизация к ядру.

### 3.2. Входные данные

| Источник | Тип данных | Описание |
|----------|------------|----------|
| Периферия | int | Номер прерывания (IRQn) для установки pending |
| Ядро | int | Номер прерывания для очистки pending |
| Ядро | bool | Запрос на проверку наличия прерываний |
| Пользователь | Команда | `irq_enable <n>`, `irq_disable <n>`, `irq_set_priority <n> <p>` |
| Шина | Запрос | Чтение/запись регистров NVIC (0xE000E100-0xE000EDFF) |

### 3.3. Выходные данные

| Получатель | Тип данных | Описание |
|------------|------------|----------|
| Ядро | bool | Сигнал о наличии ожидающего прерывания |
| Ядро | uint32_t | Адрес вектора прерывания для обработки |
| Ядро | int | Номер текущего прерывания |
| Пользователь | Структура | Состояние NVIC (ожидающие, активные, приоритеты) |

### 3.4. Внутреннее состояние

```cpp
struct NVICState {
    bool pending[43];             // Ожидающие прерывания (до 43 линий)
    bool active[43];               // Активные прерывания (в обработке)
    bool enabled[43];              // Разрешенные прерывания
    uint8_t priority[43];          // Приоритеты (0-255, меньше = выше)
    uint8_t current_priority;      // Текущий приоритет выполнения
    int current_irq;               // Текущее обрабатываемое прерывание
};
```

### 3.5. Сценарий работы: установка и проверка прерывания

```
Вход: Таймер вызывает set_pending(11)

Процесс:
1. Установка pending[11] = true
2. Если прерывание уже активно, запись в "ожидающие" (для вложенности)

Вход: Ядро вызывает has_pending_interrupt()

Процесс:
1. Поиск по всем прерываниям: enabled[n] && pending[n]
2. Сравнение приоритетов найденных прерываний
3. Выбор прерывания с наивысшим приоритетом
4. Если приоритет выбранного прерывания выше current_priority:
   - Подготовка вектора: vector_table[16 + irq_number]
   - Возврат true и номера прерывания
   Иначе:
   - Возврат false

Выход: true с номером 11 (если приоритет выше текущего)
```

### 3.6. Сценарий работы: вход в прерывание

```
Вход: Ядро вызывает acknowledge_irq(11)

Процесс:
1. active[11] = true
2. pending[11] = false
3. current_priority = priority[11]
4. current_irq = 11
5. Подготовка адреса вектора: return vector_table[16 + 11]

Выход: Адрес обработчика прерывания (0x08000120)
       Обновленное состояние NVIC
```

---

## 4. Модуль памяти (Memory)

### 4.1. Назначение
Эмуляция физической памяти микроконтроллера: Flash, SRAM, отображение периферии.

### 4.2. Входные данные

| Источник | Тип данных | Описание |
|----------|------------|----------|
| Ядро | Запрос чтения | Адрес, размер (8/16/32 бит) |
| Ядро | Запрос записи | Адрес, размер, значение |
| Пользователь | Команда | `mem_read <addr> [size]`, `mem_write <addr> <value>` |
| Пользователь | Файл | Intel HEX / бинарный файл прошивки |
| Шина | Запрос | Регистрация периферии по адресу |

### 4.3. Выходные данные

| Получатель | Тип данных | Описание |
|------------|------------|----------|
| Ядро | uint32_t | Прочитанные данные |
| Периферия | Запрос | Перенаправление операции чтения/записи (если адрес в диапазоне периферии) |
| Пользователь | Структура | Дамп памяти по запросу |
| Пользователь | Строка | Ошибка доступа (если адрес вне допустимого диапазона) |

### 4.4. Внутреннее состояние

```cpp
struct MemoryState {
    uint8_t flash[64 * 1024];      // 64 КБ Flash (0x08000000-0x0800FFFF)
    uint8_t sram[20 * 1024];       // 20 КБ SRAM (0x20000000-0x20004FFF)
    struct PeripheralMap {
        uint32_t base;
        uint32_t size;
        void* peripheral;          // Указатель на объект периферии
    } mappings[16];                // До 16 отображенных устройств
    int mapping_count;
};
```

### 4.5. Сценарий работы: чтение инструкции

```
Вход: Запрос от ядра: read(address = 0x08000100, size = 4)

Процесс:
1. Проверка диапазона:
   - Flash: 0x08000000 - 0x0800FFFF → OK
   - SRAM: 0x20000000 - 0x20004FFF
   - Периферия: проверка по mappings
2. Определение типа памяти: address в диапазоне Flash
3. Вычисление смещения: offset = address - 0x08000000 = 0x100
4. Чтение 4 байт: flash[0x100], flash[0x101], flash[0x102], flash[0x103]
5. Сборка uint32_t (little-endian): (flash[0x100] | flash[0x101]<<8 | ...)

Выход: uint32_t инструкция = 0xE0821003
```

### 4.6. Сценарий работы: запись в регистр периферии

```
Вход: Запрос от ядра: write(address = 0x40000000, size = 4, value = 0x00000001)
      (TIM2_CR1 по адресу 0x40000000)

Процесс:
1. Проверка диапазона: адрес 0x40000000
2. Поиск в mappings: найдено устройство Timer с base=0x40000000, size=0x400
3. Вычисление смещения: offset = address - 0x40000000 = 0
4. Перенаправление запроса: timer->write_register(offset, value, size)
5. Таймер выполняет свою логику записи в регистр CR1

Выход: Таймер обновляет состояние (запуск счета)
       Ядру возвращается подтверждение успешной записи
```

---

## 5. Модуль таймера (Timer)

### 5.1. Назначение
Эмуляция базового таймера TIM2: счет, предделитель, автоперезагрузка, прерывания.

### 5.2. Входные данные

| Источник | Тип данных | Описание |
|----------|------------|----------|
| Шина | Запрос | Чтение/запись регистров (CR1, SR, CNT, PSC, ARR, DIER) |
| Симулятор | int | Тактовый сигнал (tick) |
| Пользователь | Команда | `timer_show <tim>`, `timer_reset <tim>` |

### 5.3. Выходные данные

| Получатель | Тип данных | Описание |
|------------|------------|----------|
| NVIC | Запрос | set_pending(IRQn) при событии переполнения |
| Шина | uint32_t | Данные при чтении регистров |
| Пользователь | Структура | Состояние таймера (счетчик, предделитель, флаги) |

### 5.4. Внутреннее состояние

```cpp
struct TimerState {
    // Регистры
    uint32_t cr1;                  // Control register 1 (CEN, UDIS, URS, OPM и др.)
    uint32_t sr;                   // Status register (UIF - флаг обновления)
    uint32_t cnt;                   // Counter value
    uint32_t psc;                   // Prescaler (предделитель)
    uint32_t arr;                   // Auto-reload register
    uint32_t dier;                  // Interrupt enable register
    
    // Внутренние переменные
    uint32_t prescaler_counter;     // Счетчик предделителя
    bool enabled;                   // Состояние (CEN бит)
    int irq_number;                  // Номер прерывания для этого таймера
};
```

### 5.5. Сценарий работы: счет с предделителем

```
Вход: Симулятор вызывает tick(1) для Timer2
      Текущее состояние: psc = 1000, arr = 500, cnt = 123

Процесс:
1. Проверка enabled (cr1 & CEN): если 0 → выход
2. Увеличение prescaler_counter: было 900, стало 901
3. Сравнение с psc: 901 < 1000 → счетчик не увеличивается
4. Сохранение состояния

Вход: Следующий tick (после 99 вызовов)
      prescaler_counter = 999 → +1 = 1000

Процесс:
1. Достигнут prescaler: 1000 >= 1000
2. Увеличение CNT: cnt = 124
3. Сброс prescaler_counter = 0
4. Проверка переполнения: 124 < 500 → нет события
5. Если CNT достиг ARR: cnt = 500
   - Установка cnt = 0 (или reload value)
   - Установка sr |= UIF
   - Если dier & UIE → вызов nvic->set_pending(irq_number)

Выход: Новое значение cnt
       Возможно, прерывание в NVIC
```

### 5.6. Сценарий работы: запись в регистр

```
Вход: Запрос от шины: write_register(offset = 0x2C, value = 2000, size = 4)
      (0x2C = смещение регистра ARR)

Процесс:
1. Определение регистра по offset:
   - 0x00: CR1
   - 0x04: CR2 (не реализован)
   - 0x08: SMCR (не реализован)
   - 0x0C: DIER
   - 0x10: SR
   - 0x14: EGR (запись)
   - 0x18: CCMR1, CCMR2 (не реализованы)
   - 0x20: CCER (не реализован)
   - 0x24: CNT
   - 0x28: PSC
   - 0x2C: ARR ← текущий offset
2. Валидация: запись только в разрешенные биты
3. Обновление: arr = 2000
4. Специальная логика: если запись в EGR с битом UG → обновление CNT из ARR

Выход: Обновленное состояние таймера
       Подтверждение записи в шину
```

---

## 6. Модуль UART

### 6.1. Назначение
Эмуляция асинхронного приемопередатчика: передача, прием, генерация прерываний.

### 6.2. Входные данные

| Источник | Тип данных | Описание |
|----------|------------|----------|
| Шина | Запрос | Чтение/запись регистров (SR, DR, BRR, CR1) |
| Симулятор | int | Тактовый сигнал (tick) для симуляции времени передачи |
| Пользователь | char | Символ, введенный в консоли (для эмуляции приема) |
| Пользователь | Команда | `uart_send <char>`, `uart_show` |

### 6.3. Выходные данные

| Получатель | Тип данных | Описание |
|------------|------------|----------|
| NVIC | Запрос | set_pending(IRQn) при событиях (RXNE, TXE, TC) |
| Пользователь | char | Символ для вывода в консоль (передача) |
| Шина | uint32_t | Данные при чтении регистров |
| Пользователь | Структура | Состояние UART (регистры, буферы) |

### 6.4. Внутреннее состояние

```cpp
struct UARTState {
    // Регистры
    uint32_t sr;                   // Status register (RXNE, TXE, TC, и др.)
    uint32_t dr;                    // Data register
    uint32_t brr;                   // Baud rate register
    uint32_t cr1;                   // Control register 1 (UE, M, WAKE, PCE, PS, PEIE, TXEIE, TCIE, RXNEIE, и др.)
    
    // Внутренние переменные
    uint8_t tx_buffer;              // Буфер передачи
    uint8_t rx_buffer;              // Буфер приема
    bool tx_busy;                   // Идет передача
    bool rx_busy;                   // Идет прием
    uint32_t bit_counter;            // Счетчик битов для симуляции времени
    uint32_t baud_divider;           // Вычисленный делитель из BRR
    int irq_number;                  // Номер прерывания
    std::function<void(char)> output_callback;  // Коллбэк для вывода символа
};
```

### 6.5. Сценарий работы: передача символа (программная запись)

```
Вход: Ядро выполняет запись в регистр DR: write_register(offset = 0x04, value = 'A')
      Текущее состояние: TXE = 1 (буфер пуст), TC = 1 (передача завершена)

Процесс:
1. Проверка разрешения: cr1 & UE (UART включен)
2. Запись в DR: dr = 'A' (0x41)
3. Сброс флага TXE: sr &= ~TXE
4. Сброс флага TC: sr &= ~TC
5. Установка tx_busy = true
6. Инициализация bit_counter для симуляции времени передачи:
   - bit_counter = 10 * (16 * baud_divider)  // Старт, 8 бит, стоп
7. Если прерывание по TXE разрешено: NVIC не генерируется (TXE очищен)

Выход: Начало передачи
       Обновленный SR
```

### 6.6. Сценарий работы: завершение передачи (по тактам)

```
Вход: Симулятор вызывает tick(1) для UART
      Текущее состояние: tx_busy = true, bit_counter = 160 (для скорости 9600)

Процесс (повторяется каждый tick):
1. Если tx_busy:
   - bit_counter--
   - Если bit_counter == 0: передача завершена
2. При завершении передачи:
   - tx_busy = false
   - Установка sr |= TXE
   - Установка sr |= TC
   - Если cr1 & TXEIE: nvic->set_pending(irq_number)
   - Если cr1 & TCIE: nvic->set_pending(irq_number)  // обычно отдельное прерывание
   - Вызов output_callback(dr) для отображения символа

Вход: После 160 tick: передача завершена

Выход: Символ 'A' отображается в консоли пользователя
       Прерывание отправлено в NVIC (если разрешено)
       Обновленный SR
```

### 6.7. Сценарий работы: прием символа (из консоли)

```
Вход: Пользователь нажимает клавишу 'B' в интерфейсе
      UI вызывает uart->incoming_char('B')

Процесс:
1. Проверка: если sr & RXNE (буфер занят) → возможна потеря данных
2. Запись в буфер: rx_buffer = 'B'
3. Установка sr |= RXNE
4. Если cr1 & RXNEIE:
   - nvic->set_pending(irq_number)  // Запрос прерывания
5. Имитация времени приема (опционально): установка rx_busy и bit_counter

Выход: Прерывание в NVIC (если разрешено)
       Обновленный SR
```

### 6.8. Сценарий работы: чтение принятого символа

```
Вход: Ядро (в обработчике прерывания) читает регистр DR: read_register(offset = 0x04)

Процесс:
1. Чтение dr (который содержит rx_buffer)
2. Автоматический сброс флага RXNE: sr &= ~RXNE
3. Если буфер пуст, при следующем чтении вернется предыдущее значение

Выход: Значение 'B' возвращается в ядро
       Обновленный SR
```

---

## 7. Модуль контроллера шины (Bus Controller)

### 7.1. Назначение
Маршрутизация всех обращений к памяти и периферии, централизованное управление адресным пространством.

### 7.2. Входные данные

| Источник | Тип данных | Описание |
|----------|------------|----------|
| Ядро | Запрос | read(address, size), write(address, size, value) |
| Пользователь | Запрос | Регистрация нового устройства на шине |
| Инициализация | Параметры | Карта памяти (адреса и размеры регионов) |

### 7.3. Выходные данные

| Получатель | Тип данных | Описание |
|------------|------------|----------|
| Ядро | uint32_t/ошибка | Результат чтения или код ошибки |
| Память | Перенаправленный запрос | Если адрес в диапазоне памяти |
| Периферия | Перенаправленный запрос | Если адрес в диапазоне периферии |
| Пользователь | Строка | Информация о маршрутизации |

### 7.4. Внутреннее состояние

```cpp
struct BusControllerState {
    struct MemoryRegion {
        uint32_t start;
        uint32_t end;
        enum Type { FLASH, SRAM, PERIPHERAL } type;
        void* device;               // Указатель на устройство (Memory, Timer, UART...)
    } regions[32];                  // До 32 регионов памяти
    int region_count;
    
    // Кэш последних обращений для ускорения
    uint32_t last_address;
    void* last_device;
};
```

### 7.5. Сценарий работы: маршрутизация чтения

```
Вход: Ядро вызывает bus->read(0x40000010, 4)

Процесс:
1. Поиск региона, содержащего адрес 0x40000010:
   - Перебор regions от 0 до region_count-1
   - Найден регион: start=0x40000000, end=0x400003FF, type=PERIPHERAL, device=Timer2
2. Вычисление смещения: offset = address - region.start = 0x10
3. Приведение device к правильному типу: Timer* timer = (Timer*)device
4. Вызов timer->read_register(offset, 4)
5. Получение результата от таймера

Выход: Возврат значения 0x00000123 (текущее значение CNT)
       Если регион не найден: возврат ошибки и лог "Access violation at 0xXXXXXXXX"
```

---

## 8. Модуль пользовательского интерфейса (UI)

### 8.1. Назначение
Обеспечение взаимодействия пользователя с симулятором: ввод команд, отображение состояния.

### 8.2. Входные данные

| Источник | Тип данных | Описание |
|----------|------------|----------|
| Пользователь | Строка | Команды: `run`, `step`, `reg`, `mem`, `break`, `load`, `quit` |
| Симулятор | Структура | Текущее состояние всех модулей (core, nvic, timer, uart) |
| Симулятор | Событие | Точка останова, прерывание, исключение |

### 8.3. Выходные данные

| Получатель | Тип данных | Описание |
|------------|------------|----------|
| Симулятор | Команда | Управляющие команды (запуск, останов, шаг) |
| Симулятор | Запрос | Изменение состояния (установка регистров, запись в память) |
| Пользователь | Текст | Форматированный вывод состояния |
| Файл | Текст | Лог выполнения (опционально) |

### 8.4. Режимы работы

1. **Командный режим (интерактивный)**: пользователь вводит команды, симулятор отвечает
2. **Пакетный режим**: команды читаются из файла
3. **TUI режим**: постоянное обновление экрана с состоянием

### 8.5. Сценарий работы: интерактивная сессия

```
Вход: Пользователь запускает симулятор: ./simulator blinky.hex

Процесс UI:
1. Загрузка программы в память через bus->load_hex("blinky.hex")
2. Сброс системы: core->reset()
3. Отображение приглашения: "STM32 Simulator > "

Цикл обработки команд:
┌─────────────────────────────────────────────────────────────┐
│ Ввод: "reg"                                                  │
│ Процесс:                                                     │
│   1. Вызов core->get_state()                                 │
│   2. Форматирование: R0=0x00000000 R1=0x00000000 ...        │
│   3. Вывод: "R0: 0x00000000  R1: 0x00000000  R2: 0x00000000"│
│                                                              │
│ Ввод: "step 5"                                               │
│ Процесс:                                                     │
│   1. for i in 1..5: simulator->step()                       │
│   2. После каждого шага проверка точек останова             │
│   3. Вывод: "Executed 5 instructions"                        │
│                                                              │
│ Ввод: "mem 0x20000000 16"                                    │
│ Процесс:                                                     │
│   1. for i in 0..15: bus->read(0x20000000 + i, 1)           │
│   2. Форматирование в 16 колонок                             │
│   3. Вывод дампа памяти                                      │
│                                                              │
│ Ввод: "break 0x08000150"                                     │
│ Процесс:                                                     │
│   1. Добавление адреса в список точек останова               │
│   2. Вывод: "Breakpoint set at 0x08000150"                   │
│                                                              │
│ Ввод: "run"                                                  │
│ Процесс:                                                     │
│   1. Запуск цикла выполнения                                 │
│   2. При достижении breakpoint: останов и вывод "Breakpoint"│
│   3. При возникновении прерывания: отображение информации   │
│                                                              │
│ Ввод: "quit"                                                 │
│ Процесс: выход из программы                                  │
└─────────────────────────────────────────────────────────────┘

Выход: Завершение программы
       Опционально: сохранение лога в файл
```

---

## 9. Модуль отладчика (Debugger) - расширение

### 9.1. Назначение
Обеспечение расширенных возможностей отладки: точки останова, трассировка, анализ.

### 9.2. Входные данные

| Источник | Тип данных | Описание |
|----------|------------|----------|
| UI | Команда | Управление отладкой |
| Ядро | Событие | Изменение PC, выполнение инструкции |
| Пользователь | Команда | Условные точки останова, watchpoints |

### 9.3. Выходные данные

| Получатель | Тип данных | Описание |
|------------|------------|----------|
| Симулятор | Сигнал | Останов выполнения |
| UI | Событие | Уведомление о срабатывании точки останова |
| Файл | Текст | Трассировка выполнения |

### 9.4. Сценарий работы: точка останова

```
Вход: UI устанавливает breakpoint по адресу 0x08000150
      Симулятор выполняет инструкции

Процесс:
1. Перед выполнением каждой инструкции core вызывает debugger->check_breakpoint(PC)
2. Сравнение PC со списком точек останова
3. При совпадении: debugger->halt() → останов симуляции
4. Уведомление UI: "Breakpoint hit at 0x08000150"
5. Возможность продолжить, шагать, или анализировать состояние

Выход: Остановка выполнения
       Отображение состояния в UI
```

---

## 10. Общий сценарий работы эмулятора

```
НАЧАЛО
  │
  ├─► Инициализация
  │    ├─► Создание всех модулей (Core, NVIC, Memory, Timer, UART, Bus)
  │    ├─► Регистрация периферии на шине
  │    ├─► Загрузка прошивки в память (из .hex файла)
  │    └─► Сброс системы (core->reset())
  │
  ├─► Запуск пользовательского интерфейса
  │    ├─► Отображение приглашения
  │    └─► Ожидание команды
  │
  ├─► Цикл обработки команд
  │    │
  │    ├─► Команда "step N"
  │    │    └─► Цикл N раз:
  │    │         ├─► timer->tick(1)
  │    │         ├─► uart->tick(1)
  │    │         ├─► core->step()
  │    │         │    ├─► Чтение инструкции из памяти
  │    │         │    ├─► Декодирование и исполнение
  │    │         │    └─► Запись в память/регистры при необходимости
  │    │         ├─► Проверка прерываний
  │    │         └─► Проверка точек останова
  │    │
  │    ├─► Команда "run"
  │    │    └─► Бесконечный цикл (до останова):
  │    │         └─► Аналогично step, но без остановки
  │    │
  │    ├─► Команда "reg"
  │    │    └─► Получение состояния core->get_state() и вывод
  │    │
  │    ├─► Команда "mem"
  │    │    └─► Чтение памяти через bus->read() и вывод
  │    │
  │    ├─► Команда "irq"
  │    │    └─► Получение состояния nvic и вывод
  │    │
  │    ├─► Команда "timer"
  │    │    └─► Получение состояния timer и вывод
  │    │
  │    └─► Команда "quit"
  │         └─► Завершение программы
  │
  └─► КОНЕЦ
```

---

## 11. Форматы входных и выходных данных

### 11.1. Команды пользователя

```
# Управление выполнением
run                          # Запуск непрерывного выполнения
stop                         # Остановка выполнения
step [N]                     # Выполнить N инструкций (по умолчанию 1)
reset                        # Сброс системы

# Просмотр состояния
reg [name]                   # Показать все регистры или конкретный
reg name=value               # Установить значение регистра
mem <addr> [size] [count]    # Показать память по адресу
mem <addr>=<value>           # Записать значение в память
stack [count]                # Показать стек
disas [addr] [count]         # Дизассемблировать код

# Периферия
timer <tim> [show|reset]     # Управление таймером
uart <send <char>|show>      # Управление UART
irq [enable|disable] <n>     # Управление прерываниями

# Отладка
break <addr> [cond]          # Установить точку останова
break list                    # Показать все точки останова
break delete <n>
